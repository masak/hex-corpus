my @board;
sub reset_board {
    @board = ['.' xx 15] xx 15;
    for 1..13 -> $c2 { @board[0][$c2] = "V"; @board[14][$c2] = "V" }
    for 1..13 -> $c1 { @board[$c1][0] = "H"; @board[$c1][14] = "H" }
}
reset_board;

my %chains;
sub reset_chains {
    %chains =
        "V" => {
            "Cv!U" => (1..13).map(-> $c2 { [0, $c2] }),
            "Cv!D" => (1..13).map(-> $c2 { [14, $c2] }),
        },
        "H" => {
            "Ch!L" => (1..13).map(-> $c1 { [$c1, 0] }),
            "Ch!R" => (1..13).map(-> $c1 { [$c1, 14] }),
        },
    ;
}
reset_chains;

sub show_board(@links, $lastmove [$l1, $l2]) {
    my %linkpos;
    my $next_unique_letter = "a";
    for "V", "H" -> $color {
        for @links.grep(*.color eq $color)\
                  .sort(*.chains[1]).sort(*.chains[0])\
                  .classify(*.chains.join).values
        -> @l {
            my $letter = $next_unique_letter++;
            for @l -> $link {
                if %linkpos{"$link.c1();$link.c2()"} :exists {
                    %linkpos{"$link.c1();$link.c2()"} = "!";
                }
                else {
                    %linkpos{"$link.c1();$link.c2()"} = $letter;
                }
            }
        }
    }
    sub space($c1, $c2) {
        [$c1, $c2] eqv [$l1, $l2]   ?? "<" !!
        [$c1, $c2] eqv [$l1, $l2+1] ?? ">" !! " ";
    }
    for 1..13 -> $c1 {
        print " " x ($c1 - 1), space($c1, 1);
        for 1..13 -> $c2 {
            if %linkpos{"$c1;$c2"} {
                print %linkpos{"$c1;$c2"};
            }
            else {
                print @board[$c1][$c2];
            }
            print space($c1, $c2 + 1);
        }
        print "\n";
    }
    print "\n";
}

sub chain([$c1, $c2]) {
    my $color = @board[$c1][$c2];
    for %chains{$color}.kv -> $name, @coords {
        for @coords -> [$d1, $d2] {
            return $name
                if [$c1, $c2] eqv [$d1, $d2];
        }
    }
}

sub pal_chains($c1, $c2) {
    my @n = neighbors($c1, $c2);
    my $color = @board[$c1][$c2];
    sub same_color([$d1, $d2]) { $color eq @board[$d1][$d2] };
    my @sc = @n.grep: &same_color;
    my @chains = @sc.map: &chain;
    return @chains.unique;
}

sub neighbors($c1, $c2) {
    # . X X
    #  X . X
    #   X X .

    my @n;
    @n.push([$c1 - 1, $c2])     if $c1 > 0;
    @n.push([$c1 - 1, $c2 + 1]) if $c1 > 0 && $c2 < 14;
    @n.push([$c1, $c2 - 1])     if $c2 > 0;
    @n.push([$c1, $c2 + 1])     if $c2 < 14;
    @n.push([$c1 + 1, $c2 - 1]) if $c1 < 14 && $c2 > 0;
    @n.push([$c1 + 1, $c2])     if $c1 < 14;
    return @n;
}

my %next_chain_name =
    "V" => "Cv01",
    "H" => "Ch01",
;

sub seed_chain($color, $coords [$, $]) {
    my $name = %next_chain_name{$color}++;
    %chains{$color}{$name} = [$coords];
}

sub grow_chain($color, $name, $coords [$, $]) {
    %chains{$color}{$name}.push($coords);
}

sub join_chains($color, @names, $coords [$, $]) {
    my @coords = @names.map: { %chains{$color}{$_}.list };
    for @names -> $name {
        %chains{$color}{$name} :delete;
    }
    @coords.push($coords);
    my $name = %next_chain_name{$color}++;
    %chains{$color}{$name} = @coords;
}

sub show_chains {
    say "Chains:";
    for "V", "H" -> $color {
        for %chains{$color}.keys.sort -> $name {
            my @coords = %chains{$color}{$name}.list;
            if $name ~~ /'!'/ {
                @coords.splice(0, 13);
            }
            my $chain = join " ", map -> [$c1, $c2] {
                chr(ord('a') + $c2 - 1) ~ $c1
            }, %chains{$color}{$name}.list;
            if $name ~~ /'!'/ {
                say "  $name: (edge)",
                    @coords ?? " + <$chain>" !! "";
            }
            else {
                say "  $name: <$chain>";
            }
        }
        say "";
    }
}

class Link {
    has Int $.c1;
    has Int $.c2;
    has Str $.color;
    has Str @.chains;
}

sub find_links {
    my @links;
    for 1..13 -> $c1 {
        for 1..13 -> $c2 {
            next unless '.' eq @board[$c1][$c2];
            for "V", "H" -> $color {
                my @n = neighbors($c1, $c2);
                sub desired_color([$d1, $d2]) { $color eq @board[$d1][$d2] };
                my @dc = @n.grep: &desired_color;
                my @nchains = @dc.map(&chain).sort.squish;
                die "this really shouldn't happen: found a quadlink at [$c1, $c2]!"
                    if @nchains >= 4;
                for @nchains -> $ch1 {
                    for @nchains -> $ch2 {
                        next if $ch2 le $ch1;
                        my @chains = $ch1, $ch2;
                        push @links, Link.new(:$c1, :$c2, :$color, :@chains);
                    }
                }
            }
        }
    }
    return @links;
}

sub show_links(@links) {
    return unless @links;

    say "Links:";
    my $next_unique_letter = "a";
    for "V", "H" -> $color {
        for @links.grep(*.color eq $color)\
                  .sort(*.chains[1]).sort(*.chains[0])\
                  .classify(*.chains.join).values
        -> @l {
            my $letter = $next_unique_letter++;
            my $ch1 = @l[0].chains[0];
            my $ch2 = @l[0].chains[1];
            sub coord($link) { chr(ord('a') + $link.c2 - 1) ~ $link.c1 };
            say "  ($letter) $ch1 + $ch2: <{@l.map(&coord).join(" ")}>";
        }
        say "";
    }
}

sub find_snags(@links) {
    @links.classify(-> $l { "$l.color();$l.c1();$l.c2()" }).grep(*.value.elems > 1)Â».key;
}

sub MAIN($game = "hvh/466470") {
    given open($game) -> $fh {
        my &swap_coords = -> { die "swap_coords called before first move"; };

        sub process_new_move(Int $c1, Int $c2, Str $color) {
            @board[$c1][$c2] = $color;
            &swap_coords = -> { $c2, $c1 };

            my @n = pal_chains($c1, $c2);
            if @n == 0 {
                seed_chain($color, [$c1, $c2]);
            }
            elsif @n == 1 {
                grow_chain($color, @n[0], [$c1, $c2]);
            }
            else {
                join_chains($color, @n, [$c1, $c2]);
            }
            my @links = find_links;
            show_board(@links, [$c1, $c2]);

            show_chains;

            if find_snags(@links) -> @snags {
                say "Found snags: ({@snags.join(" ")})";
                say "";
                return;
            }

            show_links(@links);
        }

        for $fh.lines {
            .say;
            say "";

            when /^ (White|Black) ' places ' (\w)(\d+) '.' $/ {
                my $player = ~$0;
                my $column = ~$1;
                my $row = ~$2;

                my $color = $player eq "White" ?? "V" !! "H";
                my $c1 = +$row;
                my $c2 = ord($column) - ord("a") + 1;

                process_new_move($c1, $c2, $color);
            }

            when /^ 'Black swaps.' $/ {
                my $color = "H";
                my ($c1, $c2) = swap_coords;

                reset_board;
                reset_chains;

                process_new_move($c1, $c2, $color);
            }

            when /^ (White|Black) ' resigns.' $/ {
                say "Game over.";
            }

            when /^ (White|Black) ' times out.' $/ {
                say "Game over.";
            }

            die "could not match $_";
        }
    }
}

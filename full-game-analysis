my @board = ['.' xx 13] xx 13;
my %chains =
    "V" => {},
    "H" => {},
;

sub show_board(@links, $lastmove [$l1, $l2]) {
    my %linkpos;
    my $next_unique_letter = "a";
    for "V", "H" -> $color {
        for @links.grep(*.color eq $color)\
                  .sort(*.chains[1]).sort(*.chains[0])\
                  .classify(*.chains.join).values
        -> @l {
            my $letter = $next_unique_letter++;
            for @l -> $link {
                if %linkpos{"$link.c1();$link.c2()"} :exists {
                    %linkpos{"$link.c1();$link.c2()"} = "!";
                }
                else {
                    %linkpos{"$link.c1();$link.c2()"} = $letter;
                }
            }
        }
        say "";
    }
    sub space($c1, $c2) {
        [$c1, $c2] eqv [$l1, $l2]   ?? "<" !!
        [$c1, $c2] eqv [$l1, $l2+1] ?? ">" !! " ";
    }
    for ^13 -> $c1 {
        print " " x $c1, space($c1, 0);
        for ^13 -> $c2 {
            if %linkpos{"$c1;$c2"} {
                print %linkpos{"$c1;$c2"};
            }
            else {
                print @board[$c1][$c2];
            }
            print space($c1, $c2 + 1);
        }
        print "\n";
    }
    print "\n";
}

sub chain([$c1, $c2]) {
    my $color = @board[$c1][$c2];
    for %chains{$color}.kv -> $name, @coords {
        for @coords -> [$d1, $d2] {
            return $name
                if [$c1, $c2] eqv [$d1, $d2];
        }
    }
}

sub pal_chains($c1, $c2) {
    my @n = neighbors($c1, $c2);
    my $color = @board[$c1][$c2];
    sub same_color([$d1, $d2]) { $color eq @board[$d1][$d2] };
    my @sc = @n.grep: &same_color;
    my @chains = @sc.map: &chain;
    return @chains.unique;
}

sub neighbors($c1, $c2) {
    # . X X
    #  X . X
    #   X X .

    my @n;
    @n.push([$c1 - 1, $c2])     if $c1 > 0;
    @n.push([$c1 - 1, $c2 + 1]) if $c1 > 0 && $c2 < 12;
    @n.push([$c1, $c2 - 1])     if $c2 > 0;
    @n.push([$c1, $c2 + 1])     if $c2 < 12;
    @n.push([$c1 + 1, $c2 - 1]) if $c1 < 12 && $c2 > 0;
    @n.push([$c1 + 1, $c2])     if $c1 < 12;
    return @n;
}

my %next_chain_name =
    "V" => "Cv01",
    "H" => "Ch01",
;

sub seed_chain($color, $coords [$, $]) {
    my $name = %next_chain_name{$color}++;
    %chains{$color}{$name} = [$coords];
}

sub grow_chain($color, $name, $coords [$, $]) {
    %chains{$color}{$name}.push($coords);
}

sub join_chains($color, @names, $coords [$, $]) {
    my @coords = @names.map: { %chains{$color}{$_}.list };
    for @names -> $name {
        %chains{$color}{$name} :delete;
    }
    @coords.push($coords);
    my $name = %next_chain_name{$color}++;
    %chains{$color}{$name} = @coords;
}

sub show_chains {
    say "Chains:";
    for "V", "H" -> $color {
        for %chains{$color}.keys.sort -> $name {
            my $chain = join " ", map -> [$c1, $c2] {
                chr(ord('a') + $c2) ~ ($c1 + 1)
            }, %chains{$color}{$name}.list;
            say "  $name: <$chain>";
        }
        say "";
    }
}

class Link {
    has Int $.c1;
    has Int $.c2;
    has Str $.color;
    has Str @.chains;
}

sub find_links {
    my @links;
    for ^13 -> $c1 {
        for ^13 -> $c2 {
            next unless '.' eq @board[$c1][$c2];
            for "V", "H" -> $color {
                my @n = neighbors($c1, $c2);
                sub desired_color([$d1, $d2]) { $color eq @board[$d1][$d2] };
                my @dc = @n.grep: &desired_color;
                my @chains = @dc.map(&chain).sort.squish;
                die "found a trilink at [$c1, $c2]!"
                    if @chains > 2;
                next unless @chains == 2;
                push @links, Link.new(:$c1, :$c2, :$color, :@chains);
            }
        }
    }
    return @links;
}

sub show_links(@links) {
    return unless @links;

    say "Links:";
    my $next_unique_letter = "a";
    for "V", "H" -> $color {
        for @links.grep(*.color eq $color)\
                  .sort(*.chains[1]).sort(*.chains[0])\
                  .classify(*.chains.join).values
        -> @l {
            my $letter = $next_unique_letter++;
            my $ch1 = @l[0].chains[0];
            my $ch2 = @l[0].chains[1];
            sub coord($link) { chr(ord('a') + $link.c2) ~ ($link.c1 + 1) };
            say "  ($letter) $ch1 + $ch2: <{@l.map(&coord).join(" ")}>";
        }
        say "";
    }
}

given open("hvh/466470") -> $fh {
    for $fh.lines {
        .say;
        say "";

        when /^ (White|Black) ' places ' (\w)(\d+) '.' $/ {
            my $player = ~$0;
            my $column = ~$1;
            my $row = ~$2;

            my $color = $player eq "White" ?? "V" !! "H";
            my $c1 = $row - 1;
            my $c2 = ord($column) - ord("a");

            @board[$c1][$c2] = $color;

            die "piece near an edge"
                if $color eq "V" && $c1 == 0 | 12;
            die "piece near an edge"
                if $color eq "H" && $c2 == 0 | 12;

            my @n = pal_chains($c1, $c2);
            if @n == 0 {
                seed_chain($color, [$c1, $c2]);
            }
            elsif @n == 1 {
                grow_chain($color, @n[0], [$c1, $c2]);
            }
            else {
                join_chains($color, @n, [$c1, $c2]);
            }
            my @links = find_links;
            show_board(@links, [$c1, $c2]);

            show_chains;

            show_links(@links);
        }

        when /^ (White|Black) ' resigns.' $/ {
            say "Game over.";
            exit;
        }
        die "could not match $_";
    }
}

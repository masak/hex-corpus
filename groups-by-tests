use Test;

class Logger {
    has $.result = "";

    method log($message) {
        $!result ~= "$message\n";
    }
}

class Pos {
    has $.r;
    has $.c;

    method Str { "($.r, $.c)" }
}

class Feather {
    has Pos $.pos;
    has Pos @.helpers;
}

class Group {
    has Str $.name;
    has @.positions;

    method plumage(@board) {
        my %plumage;
        for @.positions -> $pos {
            for neighbors($pos) -> $n {
                my ($r, $c) = $n.r, $n.c;
                next unless @board[$r][$c] eq '.';
                %plumage{"$r;$c"} = Feather.new(:pos($n));
            }
            for far-neighbors($pos) -> @nhh {
                my ($n, $h1, $h2) = @nhh;
                my ($r, $c) = $n.r, $n.c;
                next unless @board[$r][$c] eq '.';
                next unless @board[$h1.r][$h1.c] eq '.';
                next unless @board[$h2.r][$h2.c] eq '.';
                next if %plumage{"$r;$c"} :exists;
                %plumage{"$r;$c%$h1,$h2"} = Feather.new(:pos($n), :helpers($h1, $h2));
            }
        }
        return %plumage.values.sort(*.pos.c).sort(*.pos.r);
    }
}

class Link {
    has Str $.name;
    has Group @.groups;
    has Pos $.pos;
    has Pos @.helpers;
}

class World {
    has Link @.links;
    has Pos @.necessary-pos;
    has Str $.unique-group-name is rw = "A";
    has Str $.unique-blocker-name is rw = "b1";
    has Int $.unique-link-name is rw = 1;
    has @.board;
    has Logger $.logger;

    method clone {
        return self.new(
            :@.links,   # XXX: this may not be enough, since we upgrade the links
            :$.unique-group-name,
            :$.unique-blocker-name,
            :$.unique-link-name,
            :board( @.board.map: -> @row { [@row] } ),
            :logger( Logger.new ),
        )
    }
}

sub is-inside($pos) { 0 <= $pos.r <= 14 && 0 <= $pos.c <= 14 }

my @deltas =
         [-1,  0], [-1, +1],
    [ 0, -1],           [ 0, +1],
         [+1, -1], [+1,  0],
;

sub neighbors($pos) {
    my ($r, $c) = $pos.r, $pos.c;

    return grep &is-inside,
        map -> [$dr, $dc] {
            Pos.new(:r($r + $dr), :c($c + $dc))
        },
        @deltas;
}

sub far-neighbors($pos) {
    my ($r, $c) = $pos.r, $pos.c;

    return grep *.[0].&is-inside,
        map -> [$rD, $cD, $r1, $c1, $r2, $c2] {
            [Pos.new(:r($rD), :c($cD)), Pos.new(:r($r1), :c($c1)), Pos.new(:r($r2), :c($c2))]
        },
        [$r-2, $c+1, $r-1, $c, $r-1, $c+1],
        [$r-1, $c-1, $r-1, $c, $r, $c-1],
        [$r-1, $c+2, $r-1, $c+1, $r, $c+1],
        [$r+1, $c-2, $r, $c-1, $r+1, $c-1],
        [$r+1, $c+1, $r, $c+1, $r+1, $c],
        [$r+2, $c-1, $r+1, $c-1, $r+1, $c],
    ;
}

sub find-chains($world) {
    my %seen;

    sub find-whole-chain($r, $c) {
        sub coords($pos) { "$pos.r();$pos.c()" }
        sub contents($pos) { $world.board[$pos.r][$pos.c] }

        my $chain = set();
        my @queue = Pos.new(:$r, :$c);
        while @queue {
            my $pos = @queue.shift;
            my $coords = "$pos.r();$pos.c()";
            next if %seen{$coords}++;

            $chain ∪= $coords;
            for neighbors($pos) -> $n {
                if contents($n) eq "#" && !%seen{coords $n} {
                    @queue.push: $n;
                }
            }
        }
        return $chain.list.map({
            /(\d+) ';' (\d+)/ or die "!";
            my ($r, $c) = +$0, +$1;
            Pos.new(:$r, :$c);
        }).sort(*.c).sort(*.r);
    }

    my @groups;
    for $world.board.kv -> $r, @row {
        for @row.kv -> $c, $piece {
            if $piece eq "/" {
                my $name = $world.unique-blocker-name++;
                $world.logger.log: "Found blocker ($name): ($r, $c)";
            }
            elsif $piece eq "#" && !%seen{"$r;$c"} {
                my $name = $world.unique-group-name++;
                my @positions = find-whole-chain($r, $c);
                @groups.push: Group.new(:$name, :@positions);
                $world.logger.log: "Found chain ($name): @positions.join(", ")";
            }
        }
    }

    return @groups;
}

sub find-links(@groups, $world) {
    for @groups X @groups -> $g1, $g2 {
        next if $g1.name ge $g2.name;
        my @p1 = $g1.plumage($world.board);
        my @p2 = $g2.plumage($world.board);
        for @p1 X @p2 -> $f1, $f2 {
            next unless $f1.pos eq $f2.pos;
            next if any($f1.helpers[]) eq any($f2.helpers[]);

            my $name = "l" ~ $world.unique-link-name++;
            my @helpers = $f1.helpers[], $f2.helpers[];
            $world.links.push: Link.new(:$name, :pos($f1.pos), :groups($g1, $g2), :@helpers);
            my $aux = @helpers ?? " % " ~ @helpers.sort(*.c).sort(*.r).join(", ") !! "";
            $world.logger.log: "Weak {$g1.name}+{$g2.name} link ($name): $f1.pos()$aux";
        }
    }
}

sub upgrade(@links, $g1, $g2, $new-group, $logger) {
    for @links {
        my $name = .name;
        my $old-groups = .groups».name.join("+");
        if .groups[0] === $g1 | $g2 {
            .groups[0] = .groups[1]; # so they are still ordered by name
        }
        .groups[1] = $new-group;
        my $new-groups = .groups».name.join("+");
        $logger.log: "    Upgrading $name: $old-groups -> $new-groups";
    }
}

sub merge-groups(@groups, $world, $orig-g1-name?, $orig-g2-name?) {
    my %eliminated;
    my $i1 = 0;
    GROUP1:
    for 0..Inf -> $i1 {
        last if $i1 >= @groups;

        my $g1 = @groups[$i1];
        next GROUP1 if %eliminated{$g1.name};

        GROUP2:
        for $i1+1..Inf -> $i2 {
            last if $i2 >= @groups;

            my $g2 = @groups[$i2];
            next GROUP1 if %eliminated{$g1.name};
            next GROUP2 if %eliminated{$g2.name};

            sub links-between-groups {
                $world.links.grep({ .groups[0] === $g1 && .groups[1] === $g2 })
            }

            sub overlap($l1, $l2) {
                any($l1.helpers) eq $l2.pos
                || $l1.pos eq any($l2.helpers)
                || any($l1.helpers) eq any($l2.helpers)
            }

            sub non-overlapping(@links) {
                for ^@links -> $i1 {
                    my $l1 = @links[$i1];
                    for $i1+1 ..^ @links -> $i2 {
                        my $l2 = @links[$i2];
                        next if overlap($l1, $l2);
                        my @nl = $l1, $l2;
                        for $i2+1 ..^ @links -> $i3 {
                            my $l3 = @links[$i3];
                            next if overlap($l1, $l3);
                            next if overlap($l2, $l3);
                            @nl.push: $l3;
                        }
                        return @nl;
                    }
                }
            }

            sub affected-links {
                my $lbg = set(links-between-groups);
                $world.links.grep({ $_ !∈ $lbg && (.groups[0] | .groups[1] === $g1 | $g2) });
            }

            my @lbg = links-between-groups();
            my @nl = non-overlapping(@lbg);
            if @nl >= 2 {
                my $name = $world.unique-group-name++;
                $world.logger.log: "Forming group ($name): $g1.name(), $g2.name() || @nl».name.join(", ")";
                my @positions = ($g1.positions[], $g2.positions[]).sort(*.c).sort(*.r);
                my $new-group = Group.new(:$name, :@positions);
                @groups.push($new-group);
                %eliminated{$g1.name}++;
                %eliminated{$g2.name}++;
                # XXX: I can imagine situations where this is not true but we should still declare success
                if defined($orig-g1-name)
                    && $orig-g1-name eq $g1.name
                    && $orig-g2-name eq $g2.name {

                    $world.necessary-pos = @nl.map({ .pos, .helpers[] }).flat;
                    return $new-group;
                }
                upgrade(affected-links(), $g1, $g2, $new-group, $world.logger);
            }
            else {
                SEARCH:
                for @lbg.sort(+*.helpers) -> $l1 {
                    for @lbg -> $l2 {
                        next if $l1 === $l2;
                        next if $l2.pos eq $l1.pos;
                        next if $l2.pos eq any($l1.helpers);

                        my $subworld = $world.clone;
                        if investigate-sacrifice($l1, $l2, $g1, $g2, $subworld) -> $group {
                            $world.logger.log: "Sacrificing {$l1.name} to try {$l2.pos}:";
                            for $subworld.logger.result.lines -> $line {
                                $world.logger.log: "    $line";
                            }
                            $world.unique-group-name = $subworld.unique-group-name;
                            $world.unique-blocker-name = $subworld.unique-blocker-name;
                            $world.unique-link-name = $subworld.unique-link-name;

                            my $link;
                            {
                                my $name = "l" ~ $world.unique-link-name++;
                                # my @helpers = ($group.links.map({ .pos, .helpers[] }).flat, $subworld.necessary-pos[]).sort(*.c).sort(*.r);
                                my @helpers = $subworld.necessary-pos[].sort(*.c).sort(*.r);
                                $link = Link.new(:$name, :pos($l2.pos), :groups($g1, $g2), :@helpers);
                                $world.links.push: $link;
                                $world.logger.log: "Weak {$g1.name}+{$g2.name} link ($name): {$l2.pos} % {@helpers.join(", ")}";
                            }
                            my @nl = $l1, $link;
                            my $name = $world.unique-group-name++;
                            $world.logger.log: "Forming group ($name): $g1.name(), $g2.name() || @nl».name.join(", ")";
                            my @positions = ($g1.positions[], $g2.positions[]).sort(*.c).sort(*.r);
                            my $new-group = Group.new(:$name, :@positions);
                            @groups.push($new-group);
                            if $orig-g1-name {
                                $world.necessary-pos = @nl.map({ .pos, .helpers[] }).flat;
                                return $new-group;
                            }
                            else {
                                %eliminated{$g1.name}++;
                                %eliminated{$g2.name}++;
                                upgrade(affected-links(), $g1, $g2, $new-group, $world.logger);
                                last SEARCH;
                            }
                        }
                    }
                }
            }
        }
    }
    @groups.=grep({ !%eliminated{.name} });
    return;
}

sub investigate-sacrifice($l1, $l2, $g1 is copy, $g2 is copy, World $world) {
    my %blockers;
    for ($l1.pos, $l1.helpers[]).sort(*.c).sort(*.r) -> $pos {
        my $blocker = $world.unique-blocker-name++;
        $world.logger.log: "Put blocker ($blocker): $pos";
        %blockers{$pos}++;
        $world.board[$pos.r][$pos.c] = "/";
    }
    my @invalidated-links = $world.links.grep: -> $l {
        %blockers{$l.pos} :exists ||
        (%blockers{$_} :exists for $l.helpers[])
    };
    $world.logger.log: "Invalidated links: @invalidated-links».name.join(", ")";
    my $invalidated-links = set(@invalidated-links».name);
    $world.links.=grep: { .name !∈ $invalidated-links };
    my $next2g1 = so any(neighbors($l2.pos)) eq any($g1.positions);
    my $next2g2 = so any(neighbors($l2.pos)) eq any($g2.positions);
    die "This is weird -- because if this condition were ever true, why are we here?"
        if $next2g1 && $next2g2;
    my $g3;
    if $next2g1 {
        $world.logger.log: "{$g1.name} extended with {$l2.pos}";
        $g1 = Group.new(:name($g1.name), :positions($g1.positions[], $l2.pos));
    }
    elsif $next2g2 {
        $world.logger.log: "{$g2.name} extended with {$l2.pos}";
        $g2 = Group.new(:name($g2.name), :positions($g2.positions[], $l2.pos));
    }
    else {
        my $name = $world.unique-group-name++;
        $world.logger.log: "Found chain ($name): {$l2.pos}";
        $g3 = Group.new(:$name, :positions($l2.pos));
    }

    # XXX: an argument could be made that this should involve *all* groups, but...
    # we're not really investigating what new links form between any groups, we're
    # investigating whether we can unite $g1 and $g2...
    # Until there's an indication that we need to involve all groups here, let's not

    my @localgroups = $g1, $g2;
    if defined $g3 {
        @localgroups.push: $g3;
    }

    find-links(@localgroups, $world);

    return merge-groups(@localgroups, $world, $g1.name, $g2.name);
}

sub infer-groups(Logger:D $logger, $board) {
    my @board = ['.' xx 15] xx 15;

    for $board.lines.kv -> $i, $line {
        my $row = $i + 1;
        for $line.comb(/\S/).kv -> $j, $char {
            my $col = $j + 1;
            @board[$row][$col] = $char;
        }
    }

    my $world = World.new(
        :@board,
        :$logger,
    );

    my @groups = find-chains($world);
    find-links(@groups, $world);
    merge-groups(@groups, $world);

    $logger.log: "Resulting groups: @groups».name.join(", ")";
}

sub empty-diff($actual is copy, $expected is copy, $desc = "<description missing>") {
    s/<!after \n> $/\n/ for $actual, $expected;  # get rid of "no newline" warnings
    spurt("/tmp/t1", $expected);
    spurt("/tmp/t2", $actual);
    my $diff = qx[diff -U2 /tmp/t1 /tmp/t2];
    $diff.=subst(/^\N+\n\N+\n/, '');  # remove uninformative headers
    is $diff, "", $desc;
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . # . . . . . . . . .
            . . . . . . . . . . . . .
             . . . . . . . . . . . . .
              . . . . . . . . . . . . .
               . . . . . . . . . . . . .
                . . . . . . . # . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "two chains far apart";
        Found chain (A): (4, 4)
        Found chain (B): (9, 8)
        Resulting groups: A, B
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . . # . . . . . .
            . . . . # . . . . . . . .
             . . . . . . . . . . . . .
              . . . . . . . . . . . . .
               . . . . . . . . . . . . .
                . . . . . . . . . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "group by bridge";
        Found chain (A): (4, 7)
        Found chain (B): (5, 5)
        Weak A+B link (l1): (4, 6)
        Weak A+B link (l2): (5, 6)
        Forming group (C): A, B || l1, l2
        Resulting groups: C
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . / # # . . . . .
            . . . . # . / # . . . . .
             . . . . # . / # . . . . .
              . . . . # . # . . . . . .
               . . . . . / . . . . . . .
                . . . . . . . . . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "group by two separate weak links";
        Found blocker (b1): (4, 6)
        Found chain (A): (4, 7), (4, 8), (5, 8), (6, 8), (7, 7)
        Found chain (B): (5, 5), (6, 5), (7, 5)
        Found blocker (b2): (5, 7)
        Found blocker (b3): (6, 7)
        Found blocker (b4): (8, 6)
        Weak A+B link (l1): (5, 6)
        Weak A+B link (l2): (7, 6)
        Forming group (C): A, B || l1, l2
        Resulting groups: C
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . # . # . . . . . .
            . . . . . . . . . . . . .
             . . . . . . . . . . . . .
              . . . . . . . . . . . . .
               . . . . . . . . . . . . .
                . . . . . . . . . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "no group formed, not enough non-overlapping weak links";
        Found chain (A): (4, 5)
        Found chain (B): (4, 7)
        Weak A+B link (l1): (3, 6) % (3, 7), (4, 6)
        Weak A+B link (l2): (3, 7) % (3, 6), (4, 6)
        Weak A+B link (l3): (4, 6)
        Weak A+B link (l4): (5, 5) % (4, 6), (5, 6)
        Weak A+B link (l5): (5, 6) % (4, 6), (5, 5)
        Resulting groups: A, B
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . . # . . . . . .
            . . . . # . . . . . . . .
             . . . . . . . . . . . . .
              . . . . . . . . . . . . .
               . . . . . . . . . # . . .
                . . . . . . . . . . . . .
                 . . . . . . . . # . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "two bridges, two groups";
        Found chain (A): (4, 7)
        Found chain (B): (5, 5)
        Found chain (C): (8, 10)
        Found chain (D): (10, 9)
        Weak A+B link (l1): (4, 6)
        Weak A+B link (l2): (5, 6)
        Weak C+D link (l3): (9, 9)
        Weak C+D link (l4): (9, 10)
        Forming group (E): A, B || l1, l2
        Forming group (F): C, D || l3, l4
        Resulting groups: E, F
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . . # . . . . . .
            . . . . # . . . . . . . .
             . . . . . / . . . . . . .
              . . . # . . . . . . . . .
               . . . . . . . . . . . . .
                . . . . . . . . . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "two bridges, one group";
        Found chain (A): (4, 7)
        Found chain (B): (5, 5)
        Found blocker (b1): (6, 6)
        Found chain (C): (7, 4)
        Weak A+B link (l1): (4, 6)
        Weak A+B link (l2): (5, 6)
        Weak B+C link (l3): (6, 4)
        Weak B+C link (l4): (6, 5)
        Forming group (D): A, B || l1, l2
            Upgrading l3: B+C -> C+D
            Upgrading l4: B+C -> C+D
        Forming group (E): C, D || l3, l4
        Resulting groups: E
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . . # # # . . . .
            . . . . # . . . # . . . .
             . . . . . . . . # . . . .
              . . . # . . . . # . . . .
               . . . # . . . # . . . . .
                . . . # # # # . . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "using up more than two weak links";
        Found chain (A): (4, 7), (4, 8), (4, 9), (5, 9), (6, 9), (7, 4), (7, 9), (8, 4), (8, 8), (9, 4), (9, 5), (9, 6), (9, 7)
        Found chain (B): (5, 5)
        Weak A+B link (l1): (4, 6)
        Weak A+B link (l2): (5, 6)
        Weak A+B link (l3): (6, 4)
        Weak A+B link (l4): (6, 5)
        Forming group (C): A, B || l1, l2, l3, l4
        Resulting groups: C
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . . # # # . . . .
            . . . . # . . . # . . . .
             . . . . . / / . # . . . .
              . . . # . . / . # . . . .
               . . . # . . / . . . . . .
                . . . # . . . # . . . . .
                 . . . # # . # . . . . . .
                  . . . . # # . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "three chains joining into one group";
        Found chain (A): (4, 7), (4, 8), (4, 9), (5, 9), (6, 9), (7, 9)
        Found chain (B): (5, 5)
        Found blocker (b1): (6, 6)
        Found blocker (b2): (6, 7)
        Found chain (C): (7, 4), (8, 4), (9, 4), (9, 8), (10, 4), (10, 5), (10, 7), (11, 5), (11, 6)
        Found blocker (b3): (7, 7)
        Found blocker (b4): (8, 7)
        Weak A+B link (l1): (4, 6)
        Weak A+B link (l2): (5, 6)
        Weak A+C link (l3): (8, 8)
        Weak A+C link (l4): (8, 9)
        Weak B+C link (l5): (6, 4)
        Weak B+C link (l6): (6, 5)
        Forming group (D): A, B || l1, l2
            Upgrading l3: A+C -> C+D
            Upgrading l4: A+C -> C+D
            Upgrading l5: B+C -> C+D
            Upgrading l6: B+C -> C+D
        Forming group (E): C, D || l3, l4, l5, l6
        Resulting groups: E
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . # . . # . . . . . .
            . . . # / . # . . . . . .
             . . . # / . # . . . . . .
              . . . # / . # . . . . . .
               . . . # / . . . . . . . .
                . . . # . . . . . . . . .
                 . . # . . . . . . . . . .
                  . . # . # . . . . . . . .
                   . . # # . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "single group by virtue of long weak links";
        Found chain (A): (4, 4), (5, 4), (6, 4), (7, 4), (8, 4), (9, 4), (10, 3), (11, 3), (11, 5), (12, 3), (12, 4)
        Found chain (B): (4, 7), (5, 7), (6, 7), (7, 7)
        Found blocker (b1): (5, 5)
        Found blocker (b2): (6, 5)
        Found blocker (b3): (7, 5)
        Found blocker (b4): (8, 5)
        Weak A+B link (l1): (3, 6) % (3, 5), (3, 7), (4, 5), (4, 6)
        Weak A+B link (l2): (9, 6) % (8, 6), (8, 7), (10, 5), (10, 6)
        Forming group (C): A, B || l1, l2
        Resulting groups: C
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . . . . . . . . .
            . . . # # . . . . . . . .
             . . # . . . . . . . . . .
              . . . . # . . . . . . . .
               . . . . . . . . . . . . .
                . . . . . . . . . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "lots of links; only two don't overlap";
        Found chain (A): (5, 4), (5, 5), (6, 3)
        Found chain (B): (7, 5)
        Weak A+B link (l1): (5, 6) % (6, 5), (6, 6)
        Weak A+B link (l2): (6, 4) % (6, 5), (7, 4)
        Weak A+B link (l3): (6, 5)
        Weak A+B link (l4): (6, 6) % (5, 6), (6, 5)
        Weak A+B link (l5): (7, 4) % (6, 4), (6, 5)
        Weak A+B link (l6): (7, 4) % (6, 4), (7, 3)
        Forming group (C): A, B || l1, l6
        Resulting groups: C
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . . . . . . . . .
            . . . # # # . . . . . . .
             . . # . . . . . . . . . .
              . . . . . # . . . . . . .
               . . . . . . . . . . . . .
                . . . . . . . . . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "simulate extending a chain to get more link info";
        Found chain (A): (5, 4), (5, 5), (5, 6), (6, 3)
        Found chain (B): (7, 6)
        Weak A+B link (l1): (5, 7) % (6, 6), (6, 7)
        Weak A+B link (l2): (6, 5) % (6, 6), (7, 5)
        Weak A+B link (l3): (6, 6)
        Weak A+B link (l4): (6, 7) % (5, 7), (6, 6)
        Weak A+B link (l5): (7, 5) % (6, 5), (6, 6)
        Sacrificing l3 to try (7, 5):
            Put blocker (b1): (6, 6)
            Invalidated links: l1, l2, l3, l4, l5
            B extended with (7, 5)
            Weak A+B link (l6): (6, 4) % (6, 5), (7, 4)
            Weak A+B link (l7): (6, 5)
            Weak A+B link (l8): (7, 4) % (6, 4), (6, 5)
            Weak A+B link (l9): (7, 4) % (6, 4), (7, 3)
            Forming group (C): A, B || l7, l9
        Weak A+B link (l10): (7, 5) % (6, 4), (6, 5), (7, 3), (7, 4)
        Forming group (D): A, B || l3, l10
        Resulting groups: D
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . . . . . . . . .
            . . . # # # # # . . . . .
             . . # . . . . . . . . . .
              . . . . . . . # . . . . .
               . . . . . . . . . . . . .
                . . . . . . . . . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "three levels deep in simulation";
        Found chain (A): (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (6, 3)
        Found chain (B): (7, 8)
        Weak A+B link (l1): (5, 9) % (6, 8), (6, 9)
        Weak A+B link (l2): (6, 7) % (6, 8), (7, 7)
        Weak A+B link (l3): (6, 8)
        Weak A+B link (l4): (6, 9) % (5, 9), (6, 8)
        Weak A+B link (l5): (7, 7) % (6, 7), (6, 8)
        Sacrificing l3 to try (7, 7):
            Put blocker (b1): (6, 8)
            Invalidated links: l1, l2, l3, l4, l5
            B extended with (7, 7)
            Weak A+B link (l6): (6, 6) % (6, 7), (7, 6)
            Weak A+B link (l7): (6, 7)
            Weak A+B link (l8): (7, 6) % (6, 6), (6, 7)
            Sacrificing l7 to try (7, 6):
                Put blocker (b2): (6, 7)
                Invalidated links: l6, l7, l8
                B extended with (7, 6)
                Weak A+B link (l9): (6, 5) % (6, 6), (7, 5)
                Weak A+B link (l10): (6, 6)
                Weak A+B link (l11): (7, 5) % (6, 5), (6, 6)
                Sacrificing l10 to try (7, 5):
                    Put blocker (b3): (6, 6)
                    Invalidated links: l9, l10, l11
                    B extended with (7, 5)
                    Weak A+B link (l12): (6, 4) % (6, 5), (7, 4)
                    Weak A+B link (l13): (6, 5)
                    Weak A+B link (l14): (7, 4) % (6, 4), (6, 5)
                    Weak A+B link (l15): (7, 4) % (6, 4), (7, 3)
                    Forming group (C): A, B || l13, l15
                Weak A+B link (l16): (7, 5) % (6, 4), (6, 5), (7, 3), (7, 4)
                Forming group (D): A, B || l10, l16
            Weak A+B link (l17): (7, 6) % (6, 4), (6, 5), (6, 6), (7, 3), (7, 4), (7, 5)
            Forming group (E): A, B || l7, l17
        Weak A+B link (l18): (7, 7) % (6, 4), (6, 5), (6, 6), (6, 7), (7, 3), (7, 4), (7, 5), (7, 6)
        Forming group (F): A, B || l3, l18
        Resulting groups: F
        LOG
}

done;
exit;

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . # # # # . . .
          . . . . . # . . . # . . .
           . . . . # . . . . # . . .
            . . . # . . . . . # . . .
             . . # # . . . . . # . . .
              . # . . . . . . . . . . .
               # . . . . . . . . . . . .
                # . . / . . . . . . . . .
                 # # # . . . . . . . . . .
                  # . / . . . . . . . . . .
                   # # . # . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/, "branching simulations leading to the group";
        Found chain (A): (2, 7), (2, 8), (2, 9), (2, 10), (3, 6), (3, 10), (4, 5), (4, 10), (5, 4), (5, 10), (6, 3), (6, 4), (6, 10), (7, 2), (8, 1), (9, 1), (10, 1), (10, 2), (10, 3), (11, 1), (12, 1), (12, 2)
        Found blocker (b1): (9, 4)
        Found blocker (b2): (11, 3)
        Found chain (B): (12, 4)
        Weak A+B link (l1): (12, 3)
        Weak A+B link (l2): (13, 2) % (12, 3), (13, 3)
        Weak A+B link (l3): (13, 3) % (12, 3), (13, 2)
        Sacrificing l1 to try (10, 5):
            Put blocker (b1): (12, 3)
            Invalidated links: l1, l2, l3
            Found chain (C): (10, 5)
            Weak A+C link (l4): (10, 4)
            Weak B+C link (l5): (11, 4)
            Weak B+C link (l6): (11, 5)
            Forming group (D): B, C || l5, l6
            Sacrificing l4 to try (8, 6):
                Put blocker (b2): (10, 4)
                Invalidated links: l4
                Found chain (E): (8, 6)
                Weak A+E link (l7): (7, 5) % (6, 5), (7, 4), (7, 6), (8, 5)
                Weak A+E link (l8): (7, 8) % (6, 9), (7, 7), (7, 9), (8, 7)
                Weak D+E link (l9): (9, 5)
                Weak D+E link (l10): (9, 6)
                Forming group (F): A, E || l7, l8
                    Upgrading l9: D+E -> D+F
                    Upgrading l10: D+E -> D+F
                Forming group (G): D, F || l9, l10
            Weak A+C link (l11): (8, 6) % (6, 5), (6, 9), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (8, 5), (8, 7), (9, 5), (9, 6)
            Forming group (G): A, C || l4, l11
        Weak A+B link (l12): (10, 5) % (6, 5), (6, 9), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (8, 5), (8, 7), (9, 5), (9, 6), (10, 4)
        Forming group (H): A, B || l1, l12
        LOG
}

done;
exit;

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . . # . . . . . .
            . . . . # . . # . . . . .
             . . . . . . . # . # . . .
              . . . . . . . # . . . . .
               . . . . . . . . . . . . .
                . . . . . . . . . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/;
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . # . .
           . . . . . . . . . # . . .
            . . . . . . . . . # . . .
             . . . . . . . . . . . # .
              . . . . . . . . . # . . .
               . . . . . . . . . . . . .
                . . . . . . . . . . . . .
                 . . . . . . . . . . . . .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/;
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . # . .
           . . . . . . . . . # . . .
            . . . . . . . . . # . . .
             . . . . . . . . . . . # .
              . . . . . . . . . # . . .
               . . . . . . . . . # . . .
                . . . . . . . . . / # . .
                 . . . . . . . . . . # # .
                  . . . . . . . . . . . . .
                   . . . . . . . . . . . . .
                    . . . . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/;
        LOG
}

given Logger.new -> $logger {
    my $board = infer-groups($logger, q:to/BOARD/);
        . . . . . . . . . . . . .
         . . . . . . . . . . . . .
          . . . . . . . . . . . . .
           . . . . . . . . . . . . .
            . . . . . . . . . . . . .
             . . . . . . . . . . . . .
              . . . . . . . . . . . . .
               . . . . # . . # / / . . .
                . . . . . # . . . # . . .
                 . . . . . . . / # . . . .
                  . . . # / # # # . . . . .
                   . . . . / / / / . . . . .
                    # # # . . . . . . . . . .
        BOARD

    empty-diff $logger.result, q:to/LOG/;
        LOG
}

done;

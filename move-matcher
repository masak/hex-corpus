class Swap { ... }
class Resignation { ... }
class Timeout { ... }
class Game { ... }

class Move {
    has Int $.n;
    has Game $.game;

    method cell($r, $c) {
        $.game.cell($.n, $r, $c);
    }
}

class Placement is Move {
    has Str $.color;
    has Int $.row;
    has Int $.col;
}

class Swap is Move {}
class Resignation is Move {}
class Timeout is Move {}

constant SIZE = 13;

sub inside { $^coord ~~ ^SIZE }
sub outside { !inside $^coord }

class Game {
    has Str $.filename;
    has Move @.moves;
    has @!board = ['empty' xx SIZE] xx SIZE;
    has $!swapped = False;

    method addMove($move) {
        @.moves.push($move);
        if $move ~~ Placement {
            @!board[$move.row][$move.col] = $move;
        }
        if $move ~~ Swap {
            $!swapped = True;
            my $firstmove = @.moves[0];
            @!board[$firstmove.row][$firstmove.col] = 'empty';
            my $row = $firstmove.col;
            my $col = $firstmove.row;
            @!board[$row][$col] = Placement.new(:n(1), :game(self), :$row, :$col);
        }
    }

    method cell($n, $r, $c) {
        return 'White'
            if outside($r) && inside($c);
        return 'Black'
            if inside($r) && outside($c);
        return 'empty'
            if outside($r) && outside($c);

        my $placement = @!board[$r][$c];
        return 'empty'
            if $placement eq 'empty';
        return 'empty'
            if $n > $placement.n;
        if $n == 0 && $!swapped {
            my $firstmove = @.moves[0];
            return $r == $firstmove.row && $c == $firstmove.col
                ?? $firstmove.color
                !! 'empty';
        }
        return $placement.color;
    }
}

class HexDB {
    has Set $.games;

    multi method addMove(Game $game, Move:U $movetype) {
        $!games ∪= $game;
        my $n = +$game.moves;
        $game.addMove($movetype.new(:$n, :$game));
    }

    multi method addMove(Game $game, Int $row, Int $col) {
        $!games ∪= $game;
        my $n = +$game.moves;
        my $color = $game.moves %% 2 ?? 'White' !! 'Black';
        my $placement = Placement.new(:$n, :$game, :$color, :$row, :$col);
        $game.addMove($placement);
    }

    method moves {
        @.games».moves.flat;
    }
}

enum PieceState <empty friendly hostile>;

sub matcher(&criteria) {
    sub match-move($m, $steps, @criteria) {
        my $friend-color = $m.color;
        my $hostile-color = $friend-color eq 'White' ?? 'Black' !! 'White';
        for @criteria -> [Int $x, Int $y, PieceState $ps] {
            my ($rot-x, $rot-y) = rotate([$x, $y], $steps);
            my $r = $m.row - $rot-y;
            my $c = $m.col + $rot-x + $rot-y;
            my $actual = $m.cell($r, $c);
            my $expected = do given $ps {
                when empty { 'empty' }
                when friendly { $friend-color }
                when hostile { $hostile-color }
            };
            return False
                unless $actual eq $expected;
        }

        return True;
    }

    my @criteria = do {
        my @*CRITERIA;
        &criteria();
        @*CRITERIA;
    };

    return Any.new but role {
        method symmetric {
            my @fs =
                { $^x + $^y, -$y },     # (1, 0)
                { $^y, $^x },           # (1, 1)
                { -$^x, $x + $^y },     # (0, 1)
                { -$^y - $^x, $y },     # (-1, 2)
                { $^x, -$^y - 2 * $x }, # (-1, 1)
                { $^x, -$x - $^y },     # (-2, 1)
            ;

            my %h = @criteria.map(-> [$x, $y, $ps] { "<$x $y> $ps" => 1 });
            FLIP:
            for @fs -> &f {
                for @criteria -> [Int $x, Int $y, PieceState $ps] {
                    my ($fx, $fy) = f($x, $y);
                    next FLIP
                        unless %h{"<$fx $fy> $ps"} :exists;
                }
                return True;
            }
            return False;
        }

        method ACCEPTS(Move $m) {
            return False
                unless $m ~~ Placement;
            for ^6 -> $steps {
                return True
                    if match-move($m, $steps, @criteria);
            }
            if !$.symmetric {
                my @flip-criteria = @criteria.map(-> [$x, $y, $ps] { [$y, $x, $ps] });
                for ^6 -> $steps {
                    return True
                        if match-move($m, $steps, @flip-criteria);
                }
            }
            return False;
        }
    };
}

sub rotate([$x is copy, $y is copy], $steps) {
    ($x, $y) = $x + $y, -$x
        for ^$steps;
    return $x, $y;
}

sub at([$x, $y], PieceState:D $ps) {
    push @*CRITERIA, [$x, $y, $ps];
}

use Test;

{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 2, 1);

    my @matches = $db.moves.grep(matcher {;});

    is +@matches, 1, "one move found, because we're matching on everything";
}

#    . . b .
#     . . . A      A = <3, 5>
#      . C . .     C = <4, 3>
{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 3, 5);
    $db.addMove($game, 2, 4);
    $db.addMove($game, 4, 3);

    my @matches = $db.moves.grep(matcher {
        at [1, 1], friendly;
    });

    is +@matches, 1, "there are three moves, but only C matches the criterion";
}

#    . . b .
#     . . ? A      A = <3, 5>
#      . C . .     C = <4, 3>
{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 3, 5);
    $db.addMove($game, 2, 4);
    $db.addMove($game, 4, 3);

    my @matches = $db.moves.grep(matcher {
        at [1, 1], friendly;
        at [1, 0], friendly;
    });

    is +@matches, 0, "this search matches no moves";
}

#    . . b .
#     . . . A      A = <3, 5>
#      . C . .     C = <4, 3>
{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 3, 5);
    $db.addMove($game, 2, 4);
    $db.addMove($game, 4, 3);

    my @matches = $db.moves.grep(matcher {
        at [1, 1], friendly;
        at [1, 0], empty;
    });

    is +@matches, 1, "this one, however, does match; asserting an empty cell";
}

#    . d b .       b = <0, 2>  d = <0, 1>
#     . . . A
#      . C . .
{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 1, 3);
    $db.addMove($game, 0, 2);
    $db.addMove($game, 2, 1);
    $db.addMove($game, 0, 1);

    my @matches = $db.moves.grep(matcher {
        at [1, 0], friendly;
    });

    is +@matches, 1, "a friendly cell can be black";
}

#    . . C .       C = <2, 4>
#     . . . b
#      . A . .     C = <4, 3>
{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 4, 3);
    $db.addMove($game, 3, 5);
    $db.addMove($game, 2, 4);

    my @matches = $db.moves.grep(matcher {
        at [1, 1], friendly;
        at [1, 0], empty;
        at [0, 1], empty;
    });

    is +@matches, 1, "the pattern matches even when rotated";
}

#    . . . .
#     . . A .      A = <1, 2>
#      . . . .
{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 1, 2);

    my @matches = $db.moves.grep(matcher {
        at [1, 1], friendly;
        at [1, 0], empty;
        at [0, 1], empty;
    });

    is +@matches, 1, "a stone can match past an edge";
}

#    . . A .
#     . b . .      b = <1, 1>
#      . . . .
{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 0, 2);
    $db.addMove($game, 1, 1);

    my @matches = $db.moves.grep(matcher {
        at [1, 1], friendly;
        at [1, 0], empty;
        at [0, 1], empty;
    });

    is +@matches, 1, "stones match only their own edge";
}

#    . . A .    (swapped out)
#     . . . C
#      b d . .
{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 3, 2);
    $db.addMove($game, Swap);   # so there's now a Black stone at (2, 3)
    $db.addMove($game, 4, 3);

    my @bridges = $db.moves.grep(matcher {
        at [1, 1], friendly;
        at [1, 0], empty;
        at [0, 1], empty;
    });

    is +@bridges, 0, "no bridge because that stone was swapped away";
}

{
    my $matcher = matcher {
        at [1, 1], friendly;
    };
    ok $matcher.symmetric, "matcher is mirror-symmetric";
}

{
    my $matcher = matcher {
        at [1, 1], friendly;
        at [2, 0], friendly;
    };
    ok !$matcher.symmetric, "matcher is not mirror-symmetric";
}

{
    my $matcher = matcher {
        at [0, 1], friendly;
        at [1, -1], friendly;
    };
    ok $matcher.symmetric, "matcher is mirror-symmetric, but along a different line";
}

{
    my $matcher = matcher {
        at [1, 0], friendly;
        at [-1, 1], friendly;
    };
    ok $matcher.symmetric, "a third symmetry line";
}

{
    my $matcher = matcher {
        at [-1, 2], friendly;
        at [-1, 0], friendly;
    };
    ok $matcher.symmetric, "a fourth symmetry line";
}

{
    my $matcher = matcher {
        at [-1, 1], friendly;
        at [0, 1], friendly;
    };
    ok $matcher.symmetric, "a fifth symmetry line";
}

{
    my $matcher = matcher {
        at [-1, 2], friendly;
        at [-1, -1], friendly;
    };
    ok $matcher.symmetric, "a sixth symmetry line";
}

#    . . b .       b = <2, 4>
#     . . . A      A = <3, 5>
#      . C . .     C = <4, 3>
{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 3, 5);
    $db.addMove($game, 2, 4);
    $db.addMove($game, 4, 3);

    my @matches = $db.moves.grep(matcher {
        at [1, 1], friendly;
        at [-1, 2], hostile;
    });

    is +@matches, 1, "knows how to match hostile pieces";
}

#    . . b .       b = <2, 4>
#     . . . A      A = <3, 5>
#      . C . .     C = <4, 3>
{
    my $db = HexDB.new;
    my $game = Game.new(:filename<testgame>);
    $db.addMove($game, 3, 5);
    $db.addMove($game, 2, 4);
    $db.addMove($game, 4, 3);

    my @matches = $db.moves.grep(matcher {
        at [1, 1], friendly;
        at [2, -1], hostile;
    });

    is +@matches, 1, "can match against mirror images";
}

done;
